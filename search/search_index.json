{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Thors Hammer","text":"<p>ADD TAGS HERE</p> <p><code>thors-hammer</code> provides an SDK for interfacing with Broadworks (BWKS) OCIP SOAP interface.</p> <p>Officially adopted by Fourteen IP Communications leading supplier of hosted telephony in the hospitality industry. </p> <ul> <li>Documentation</li> </ul> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>Thors Hammer is a SDK with extensive documentation, automation, and more to better manage BWKS instances. </p> <p>The package is currently actively managed by the Dev Team at Fourteen IP. The team is working with the whole company including platform and telephony engineers with decades of experience. </p> <p>The goal of the solution is to ease the management of BWKS and give engineers tooling to better configure and administrate.</p> <p>The tool takes advantage of the amazing work by the developers of broadworks-ocip. Thor's Hammer has been slightly modified to interact with SOAP API instead of using TCP. </p> <p>[!NOTE] If you are are looking to interact with the SOAP API however you do not need the additional features of Thors Hammer you can alternatively use broadworks-ocip-soap.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Interface with Broadworks OCIP SOAP API</li> <li>Provides automation features for common issues (requested by BWKS engineers with decades of experience)</li> <li>Provides automated reporting </li> <li>Command logic to seamlessly use API </li> </ul> <p>[!NOTE] If you would like to submit a feature request please raise an issue detailing your request.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install Thors Hammer using pip:</p> <pre><code>pip install thors-hammer\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example to get you started:</p> <pre><code>from thors_hammer import API, Scripter, Reporter\n\n# Initialize the API with your credentials\napi = API(url=\"https://soap_api_url/\", username=\"john.smith\", password=\"your password\", user_agent=\"Thors Hammer\")\n\nassistant = Scripter(api)\n# Locate an alias assignment\nalias_info = assistant.find_alias('ServiceProviderID', 'GroupID', alias=0)\n\nassistant = Reporter(api)\n# Generate visual call flow image. Saved as PNG.\nassistant.call_flow(\n    'serviceProviderId',\n    'groupId',\n    '3001',\n    'extension',\n    'auto_attendant'\n)\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This package builds upon the excellent work of the original Broadworks OCI-P Interface package. Special thanks to:</p> <p>@nigelm (Nigel Metheringham) \u2013 Developer of the original Python version.</p> <p>Karol Skibi\u0144ski \u2013 For extensive testing, bug reporting, and valuable contributions.</p> <p>@ewurch (Eduardo W\u00fcrch) \u2013 For contributing the R25 schema update and other improvements.</p> <p>Additionally, thank you to the Dev Team at Fourteen IP for the active manage and development of the tool.</p>"},{"location":"client/async-client/","title":"Async Version of Client","text":"<p>This module behaves the same as <code>Client</code> but offers Async capabilities.</p> <p>Note</p> <p>It is on you the user to implement async this module simply allows for the ability to do so</p> <p>               Bases: <code>BaseClient</code></p> <p>Asycn version of Client.</p> <p>Note: Performs the same functions as Client, but in an asynchronous manner.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>URL or IP address of server. Depends on connection type.</p> required <code>username</code> <code>str</code> <p>The username of the user</p> required <code>password</code> <code>str</code> <p>The password of the user</p> required <code>conn_type</code> <code>str</code> <p>Either 'TCP' or 'SOAP'. TCP is the default.</p> required <code>user_agent</code> <code>str</code> <p>The user agent of the client, used for logging. Default is 'Thor's Hammer'. </p> required <code>timeout</code> <code>int</code> <p>The timeout of the client. Default is 30 seconds.</p> required <code>logger</code> <code>Logger</code> <p>The logger of the client. Default is None.</p> required <p>Attributes:</p> Name Type Description <code>authenticated</code> <code>bool</code> <p>Whether the client is authenticated</p> <code>session_id</code> <code>str</code> <p>The session id of the client</p> <code>dispatch_table</code> <code>dict</code> <p>The dispatch table of the client</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the client fails to authenticate</p> Source code in <code>src/thors_hammer/client.py</code> <pre><code>class AsyncClient(BaseClient):\n    \"\"\"Asycn version of Client.\n\n    Note: Performs the same functions as Client, but in an asynchronous manner.\n\n    Args:\n        host (str): URL or IP address of server. Depends on connection type.\n        username (str): The username of the user\n        password (str): The password of the user\n        conn_type (str): Either 'TCP' or 'SOAP'. TCP is the default.\n        user_agent (str): The user agent of the client, used for logging. Default is 'Thor\\'s Hammer'. \n        timeout (int): The timeout of the client. Default is 30 seconds.\n        logger (logging.Logger): The logger of the client. Default is None.\n\n    Attributes:\n        authenticated (bool): Whether the client is authenticated\n        session_id (str): The session id of the client\n        dispatch_table (dict): The dispatch table of the client\n\n    Raises:\n        Exception: If the client fails to authenticate\n    \"\"\"\n\n    @property\n    def async_mode(self) -&gt; bool:\n        return True\n\n    async def command(self, command: BWKSCommand) -&gt; BWKSCommand:\n        if not self.authenticated:\n            await self.authenticate()\n        self.logger.info(f\"Executing command: {command.__class__.__name__}\")\n        self.logger.debug(f\"Command: {command.to_dict()}\")\n        response = await self.requester.send_request(command.to_xml())\n        return self._receive_response(response)\n\n    async def raw_command(self, command: str, **kwargs) -&gt; BWKSCommand:\n        command_class = self.dispatch_table.get(command)\n        if not command_class:\n            self.logger.error(f\"Command {command} not found in dispatch table\")\n            raise ValueError(f\"Command {command} not found in dispatch table\")\n        response = await self.command(command_class(**kwargs))\n        return response\n\n    async def authenticate(self) -&gt; BWKSCommand:\n        if self.authenticated:\n            return\n        try:        \n            auth_command = self.dispatch_table.get(\"AuthenticationRequest\")\n            auth_resp = await self.command(auth_command(user_id=self.username))\n\n            authhash = hashlib.sha1(self.password.encode()).hexdigest().lower()\n            signed_password = (\n                hashlib.md5(\":\".join([auth_resp.nonce, authhash]).encode())\n                .hexdigest()\n                .lower()\n            )\n\n            login_command = self.dispatch_table.get(\"LoginResponse22V5\")\n            login_resp = await self.command(\n                login_command(user_id=self.username, signed_password=signed_password)\n            )\n        except Exception as e:\n            self.logger.error(f\"Failed to authenticate: {e}\")\n            raise THError(f\"Failed to authenticate: {e}\")\n        self.logger.info(\"Authenticated with server\")\n        self.authenticated = True\n        return login_resp\n\n    def _receive_response(self, response: str) -&gt; BWKSCommand: #TODO: this needs flushing out\n        \"\"\"Receives response from requester and returns BWKSCommand\"\"\"\n        return BWKSCommand.from_xml(response)\n</code></pre>"},{"location":"client/client/","title":"Main Client","text":"<p>Core module of library and must be imported and instantiated.</p> <p>               Bases: <code>BaseClient</code></p> <p>Connection to a BroadWorks server</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>URL or IP address of server. Depends on connection type.</p> required <code>username</code> <code>str</code> <p>The username of the user</p> required <code>password</code> <code>str</code> <p>The password of the user</p> required <code>conn_type</code> <code>str</code> <p>Either 'TCP' or 'SOAP'. TCP is the default.</p> required <code>user_agent</code> <code>str</code> <p>The user agent of the client, used for logging. Default is 'Thor's Hammer'. </p> required <code>timeout</code> <code>int</code> <p>The timeout of the client. Default is 30 seconds.</p> required <code>logger</code> <code>Logger</code> <p>The logger of the client. Default is None.</p> required <p>Attributes:</p> Name Type Description <code>authenticated</code> <code>bool</code> <p>Whether the client is authenticated</p> <code>session_id</code> <code>str</code> <p>The session id of the client</p> <code>dispatch_table</code> <code>dict</code> <p>The dispatch table of the client</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the client fails to authenticate</p> Source code in <code>src/thors_hammer/client.py</code> <pre><code>class Client(BaseClient):\n    \"\"\"Connection to a BroadWorks server\n\n    Args:\n        host (str): URL or IP address of server. Depends on connection type.\n        username (str): The username of the user\n        password (str): The password of the user\n        conn_type (str): Either 'TCP' or 'SOAP'. TCP is the default.\n        user_agent (str): The user agent of the client, used for logging. Default is 'Thor\\'s Hammer'. \n        timeout (int): The timeout of the client. Default is 30 seconds.\n        logger (logging.Logger): The logger of the client. Default is None.\n\n    Attributes:\n        authenticated (bool): Whether the client is authenticated\n        session_id (str): The session id of the client\n        dispatch_table (dict): The dispatch table of the client\n\n    Raises:\n        Exception: If the client fails to authenticate\n    \"\"\"\n\n    @property\n    def async_mode(self) -&gt; bool:\n        return False\n\n    def command(self, command: BWKSCommand) -&gt; BWKSCommand:\n        \"\"\"\n        Executes all requests to the server.\n        If the client is not authenticated, it will authenticate first.\n\n        Args:\n            command (BWKSCommand): The command class to execute\n\n        Returns:\n            BWKSCommand: The response from the server\n        \"\"\"\n        if not self.authenticated:\n            self.authenticate()\n        self.logger.info(f\"Executing command: {command.__class__.__name__}\")\n        self.logger.debug(f\"Command: {command.to_dict()}\")\n        response = self.requester.send_request(command.to_xml())\n        return self._receive_response(response)\n\n    def raw_command(self, command: str, **kwargs) -&gt; BWKSCommand:\n        \"\"\"\n        Executes raw command specified by end user - instantiates class command.\n\n        Args:\n            command (str): The command to execute\n            **kwargs: The arguments to pass to the command\n\n        Returns:\n            BWKSCommand: The response from the server\n\n        Raises:\n            ValueError: If the command is not found in the dispatch table\n        \"\"\"\n        command_class = self.dispatch_table.get(command)\n        if not command_class:\n            self.logger.error(f\"Command {command} not found in dispatch table\")\n            raise ValueError(f\"Command {command} not found in dispatch table\")\n        return self.command(command_class(**kwargs))\n\n    def authenticate(self) -&gt; BWKSCommand:\n        \"\"\"\n        Authenticates client with username and password in client.\n\n        Returns:\n            BWKSCommand: The response from the server\n\n        Raises:\n            ValueError: If the command is not found in the dispatch table\n        \"\"\"\n        if self.authenticated:\n            return\n        try: \n            auth_command = self.dispatch_table.get(\"AuthenticationRequest\")\n            auth_resp = self.command(auth_command(user_id=self.username))\n\n            authhash = hashlib.sha1(self.password.encode()).hexdigest().lower()\n            signed_password = (\n                hashlib.md5(\":\".join([auth_resp.nonce, authhash]).encode())\n                .hexdigest()\n                .lower()\n            )\n\n            login_command = self.dispatch_table.get(\"LoginResponse22V5\")\n            login_resp = self.command(\n                login_command(user_id=self.username, signed_password=signed_password)\n            )\n        except Exception as e:\n            self.logger.error(f\"Failed to authenticate: {e}\")\n            raise THError(f\"Failed to authenticate: {e}\")\n        self.logger.info(\"Authenticated with server\")\n        self.authenticated = True\n        return login_resp\n\n    def _receive_response(self, response: str) -&gt; BWKSCommand:\n        \"\"\"Receives response from requester and returns BWKSCommand\"\"\"\n        return BWKSCommand.from_xml(response)\n</code></pre>"},{"location":"client/client/#thors_hammer.client.Client.authenticate","title":"<code>authenticate()</code>","text":"<p>Authenticates client with username and password in client.</p> <p>Returns:</p> Name Type Description <code>BWKSCommand</code> <code>BroadworksCommand</code> <p>The response from the server</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the command is not found in the dispatch table</p> Source code in <code>src/thors_hammer/client.py</code> <pre><code>def authenticate(self) -&gt; BWKSCommand:\n    \"\"\"\n    Authenticates client with username and password in client.\n\n    Returns:\n        BWKSCommand: The response from the server\n\n    Raises:\n        ValueError: If the command is not found in the dispatch table\n    \"\"\"\n    if self.authenticated:\n        return\n    try: \n        auth_command = self.dispatch_table.get(\"AuthenticationRequest\")\n        auth_resp = self.command(auth_command(user_id=self.username))\n\n        authhash = hashlib.sha1(self.password.encode()).hexdigest().lower()\n        signed_password = (\n            hashlib.md5(\":\".join([auth_resp.nonce, authhash]).encode())\n            .hexdigest()\n            .lower()\n        )\n\n        login_command = self.dispatch_table.get(\"LoginResponse22V5\")\n        login_resp = self.command(\n            login_command(user_id=self.username, signed_password=signed_password)\n        )\n    except Exception as e:\n        self.logger.error(f\"Failed to authenticate: {e}\")\n        raise THError(f\"Failed to authenticate: {e}\")\n    self.logger.info(\"Authenticated with server\")\n    self.authenticated = True\n    return login_resp\n</code></pre>"},{"location":"client/client/#thors_hammer.client.Client.command","title":"<code>command(command)</code>","text":"<p>Executes all requests to the server. If the client is not authenticated, it will authenticate first.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>BroadworksCommand</code> <p>The command class to execute</p> required <p>Returns:</p> Name Type Description <code>BWKSCommand</code> <code>BroadworksCommand</code> <p>The response from the server</p> Source code in <code>src/thors_hammer/client.py</code> <pre><code>def command(self, command: BWKSCommand) -&gt; BWKSCommand:\n    \"\"\"\n    Executes all requests to the server.\n    If the client is not authenticated, it will authenticate first.\n\n    Args:\n        command (BWKSCommand): The command class to execute\n\n    Returns:\n        BWKSCommand: The response from the server\n    \"\"\"\n    if not self.authenticated:\n        self.authenticate()\n    self.logger.info(f\"Executing command: {command.__class__.__name__}\")\n    self.logger.debug(f\"Command: {command.to_dict()}\")\n    response = self.requester.send_request(command.to_xml())\n    return self._receive_response(response)\n</code></pre>"},{"location":"client/client/#thors_hammer.client.Client.raw_command","title":"<code>raw_command(command, **kwargs)</code>","text":"<p>Executes raw command specified by end user - instantiates class command.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to execute</p> required <code>**kwargs</code> <p>The arguments to pass to the command</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BWKSCommand</code> <code>BroadworksCommand</code> <p>The response from the server</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the command is not found in the dispatch table</p> Source code in <code>src/thors_hammer/client.py</code> <pre><code>def raw_command(self, command: str, **kwargs) -&gt; BWKSCommand:\n    \"\"\"\n    Executes raw command specified by end user - instantiates class command.\n\n    Args:\n        command (str): The command to execute\n        **kwargs: The arguments to pass to the command\n\n    Returns:\n        BWKSCommand: The response from the server\n\n    Raises:\n        ValueError: If the command is not found in the dispatch table\n    \"\"\"\n    command_class = self.dispatch_table.get(command)\n    if not command_class:\n        self.logger.error(f\"Command {command} not found in dispatch table\")\n        raise ValueError(f\"Command {command} not found in dispatch table\")\n    return self.command(command_class(**kwargs))\n</code></pre>"}]}